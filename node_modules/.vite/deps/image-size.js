import {
  __commonJS
} from "./chunk-AC2VUBZ6.js";

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// ../../../node_modules/events/events.js
var require_events = __commonJS({
  "../../../node_modules/events/events.js"(exports, module) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module.exports = EventEmitter;
    module.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/queue/index.js
var require_queue = __commonJS({
  "node_modules/queue/index.js"(exports, module) {
    var inherits = require_inherits_browser();
    var EventEmitter = require_events().EventEmitter;
    module.exports = Queue;
    module.exports.default = Queue;
    function Queue(options) {
      if (!(this instanceof Queue)) {
        return new Queue(options);
      }
      EventEmitter.call(this);
      options = options || {};
      this.concurrency = options.concurrency || Infinity;
      this.timeout = options.timeout || 0;
      this.autostart = options.autostart || false;
      this.results = options.results || null;
      this.pending = 0;
      this.session = 0;
      this.running = false;
      this.jobs = [];
      this.timers = {};
    }
    inherits(Queue, EventEmitter);
    var arrayMethods = [
      "pop",
      "shift",
      "indexOf",
      "lastIndexOf"
    ];
    arrayMethods.forEach(function(method) {
      Queue.prototype[method] = function() {
        return Array.prototype[method].apply(this.jobs, arguments);
      };
    });
    Queue.prototype.slice = function(begin, end) {
      this.jobs = this.jobs.slice(begin, end);
      return this;
    };
    Queue.prototype.reverse = function() {
      this.jobs.reverse();
      return this;
    };
    var arrayAddMethods = [
      "push",
      "unshift",
      "splice"
    ];
    arrayAddMethods.forEach(function(method) {
      Queue.prototype[method] = function() {
        var methodResult = Array.prototype[method].apply(this.jobs, arguments);
        if (this.autostart) {
          this.start();
        }
        return methodResult;
      };
    });
    Object.defineProperty(Queue.prototype, "length", {
      get: function() {
        return this.pending + this.jobs.length;
      }
    });
    Queue.prototype.start = function(cb) {
      if (cb) {
        callOnErrorOrEnd.call(this, cb);
      }
      this.running = true;
      if (this.pending >= this.concurrency) {
        return;
      }
      if (this.jobs.length === 0) {
        if (this.pending === 0) {
          done.call(this);
        }
        return;
      }
      var self = this;
      var job = this.jobs.shift();
      var once = true;
      var session = this.session;
      var timeoutId = null;
      var didTimeout = false;
      var resultIndex = null;
      var timeout = job.hasOwnProperty("timeout") ? job.timeout : this.timeout;
      function next(err, result) {
        if (once && self.session === session) {
          once = false;
          self.pending--;
          if (timeoutId !== null) {
            delete self.timers[timeoutId];
            clearTimeout(timeoutId);
          }
          if (err) {
            self.emit("error", err, job);
          } else if (didTimeout === false) {
            if (resultIndex !== null) {
              self.results[resultIndex] = Array.prototype.slice.call(arguments, 1);
            }
            self.emit("success", result, job);
          }
          if (self.session === session) {
            if (self.pending === 0 && self.jobs.length === 0) {
              done.call(self);
            } else if (self.running) {
              self.start();
            }
          }
        }
      }
      if (timeout) {
        timeoutId = setTimeout(function() {
          didTimeout = true;
          if (self.listeners("timeout").length > 0) {
            self.emit("timeout", next, job);
          } else {
            next();
          }
        }, timeout);
        this.timers[timeoutId] = timeoutId;
      }
      if (this.results) {
        resultIndex = this.results.length;
        this.results[resultIndex] = null;
      }
      this.pending++;
      self.emit("start", job);
      var promise = job(next);
      if (promise && promise.then && typeof promise.then === "function") {
        promise.then(function(result) {
          return next(null, result);
        }).catch(function(err) {
          return next(err || true);
        });
      }
      if (this.running && this.jobs.length > 0) {
        this.start();
      }
    };
    Queue.prototype.stop = function() {
      this.running = false;
    };
    Queue.prototype.end = function(err) {
      clearTimers.call(this);
      this.jobs.length = 0;
      this.pending = 0;
      done.call(this, err);
    };
    function clearTimers() {
      for (var key in this.timers) {
        var timeoutId = this.timers[key];
        delete this.timers[key];
        clearTimeout(timeoutId);
      }
    }
    function callOnErrorOrEnd(cb) {
      var self = this;
      this.on("error", onerror);
      this.on("end", onend);
      function onerror(err) {
        self.end(err);
      }
      function onend(err) {
        self.removeListener("error", onerror);
        self.removeListener("end", onend);
        cb(err, this.results);
      }
    }
    function done(err) {
      this.session++;
      this.running = false;
      this.emit("end", err);
    }
  }
});

// node_modules/image-size/dist/types/bmp.js
var require_bmp = __commonJS({
  "node_modules/image-size/dist/types/bmp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BMP = void 0;
    exports.BMP = {
      validate(buffer) {
        return "BM" === buffer.toString("ascii", 0, 2);
      },
      calculate(buffer) {
        return {
          height: Math.abs(buffer.readInt32LE(22)),
          width: buffer.readUInt32LE(18)
        };
      }
    };
  }
});

// node_modules/image-size/dist/types/ico.js
var require_ico = __commonJS({
  "node_modules/image-size/dist/types/ico.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ICO = void 0;
    var TYPE_ICON = 1;
    var SIZE_HEADER = 2 + 2 + 2;
    var SIZE_IMAGE_ENTRY = 1 + 1 + 1 + 1 + 2 + 2 + 4 + 4;
    function getSizeFromOffset(buffer, offset) {
      const value = buffer.readUInt8(offset);
      return value === 0 ? 256 : value;
    }
    function getImageSize(buffer, imageIndex) {
      const offset = SIZE_HEADER + imageIndex * SIZE_IMAGE_ENTRY;
      return {
        height: getSizeFromOffset(buffer, offset + 1),
        width: getSizeFromOffset(buffer, offset)
      };
    }
    exports.ICO = {
      validate(buffer) {
        const reserved = buffer.readUInt16LE(0);
        const imageCount = buffer.readUInt16LE(4);
        if (reserved !== 0 || imageCount === 0) {
          return false;
        }
        const imageType = buffer.readUInt16LE(2);
        return imageType === TYPE_ICON;
      },
      calculate(buffer) {
        const nbImages = buffer.readUInt16LE(4);
        const imageSize = getImageSize(buffer, 0);
        if (nbImages === 1) {
          return imageSize;
        }
        const imgs = [imageSize];
        for (let imageIndex = 1; imageIndex < nbImages; imageIndex += 1) {
          imgs.push(getImageSize(buffer, imageIndex));
        }
        const result = {
          height: imageSize.height,
          images: imgs,
          width: imageSize.width
        };
        return result;
      }
    };
  }
});

// node_modules/image-size/dist/types/cur.js
var require_cur = __commonJS({
  "node_modules/image-size/dist/types/cur.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CUR = void 0;
    var ico_1 = require_ico();
    var TYPE_CURSOR = 2;
    exports.CUR = {
      validate(buffer) {
        const reserved = buffer.readUInt16LE(0);
        const imageCount = buffer.readUInt16LE(4);
        if (reserved !== 0 || imageCount === 0) {
          return false;
        }
        const imageType = buffer.readUInt16LE(2);
        return imageType === TYPE_CURSOR;
      },
      calculate(buffer) {
        return ico_1.ICO.calculate(buffer);
      }
    };
  }
});

// node_modules/image-size/dist/types/dds.js
var require_dds = __commonJS({
  "node_modules/image-size/dist/types/dds.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DDS = void 0;
    exports.DDS = {
      validate(buffer) {
        return buffer.readUInt32LE(0) === 542327876;
      },
      calculate(buffer) {
        return {
          height: buffer.readUInt32LE(12),
          width: buffer.readUInt32LE(16)
        };
      }
    };
  }
});

// node_modules/image-size/dist/types/gif.js
var require_gif = __commonJS({
  "node_modules/image-size/dist/types/gif.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GIF = void 0;
    var gifRegexp = /^GIF8[79]a/;
    exports.GIF = {
      validate(buffer) {
        const signature = buffer.toString("ascii", 0, 6);
        return gifRegexp.test(signature);
      },
      calculate(buffer) {
        return {
          height: buffer.readUInt16LE(8),
          width: buffer.readUInt16LE(6)
        };
      }
    };
  }
});

// node_modules/image-size/dist/types/icns.js
var require_icns = __commonJS({
  "node_modules/image-size/dist/types/icns.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ICNS = void 0;
    var SIZE_HEADER = 4 + 4;
    var FILE_LENGTH_OFFSET = 4;
    var ENTRY_LENGTH_OFFSET = 4;
    var ICON_TYPE_SIZE = {
      ICON: 32,
      "ICN#": 32,
      // m => 16 x 16
      "icm#": 16,
      icm4: 16,
      icm8: 16,
      // s => 16 x 16
      "ics#": 16,
      ics4: 16,
      ics8: 16,
      is32: 16,
      s8mk: 16,
      icp4: 16,
      // l => 32 x 32
      icl4: 32,
      icl8: 32,
      il32: 32,
      l8mk: 32,
      icp5: 32,
      ic11: 32,
      // h => 48 x 48
      ich4: 48,
      ich8: 48,
      ih32: 48,
      h8mk: 48,
      // . => 64 x 64
      icp6: 64,
      ic12: 32,
      // t => 128 x 128
      it32: 128,
      t8mk: 128,
      ic07: 128,
      // . => 256 x 256
      ic08: 256,
      ic13: 256,
      // . => 512 x 512
      ic09: 512,
      ic14: 512,
      // . => 1024 x 1024
      ic10: 1024
    };
    function readImageHeader(buffer, imageOffset) {
      const imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;
      return [
        buffer.toString("ascii", imageOffset, imageLengthOffset),
        buffer.readUInt32BE(imageLengthOffset)
      ];
    }
    function getImageSize(type) {
      const size = ICON_TYPE_SIZE[type];
      return { width: size, height: size, type };
    }
    exports.ICNS = {
      validate(buffer) {
        return "icns" === buffer.toString("ascii", 0, 4);
      },
      calculate(buffer) {
        const bufferLength = buffer.length;
        const fileLength = buffer.readUInt32BE(FILE_LENGTH_OFFSET);
        let imageOffset = SIZE_HEADER;
        let imageHeader = readImageHeader(buffer, imageOffset);
        let imageSize = getImageSize(imageHeader[0]);
        imageOffset += imageHeader[1];
        if (imageOffset === fileLength) {
          return imageSize;
        }
        const result = {
          height: imageSize.height,
          images: [imageSize],
          width: imageSize.width
        };
        while (imageOffset < fileLength && imageOffset < bufferLength) {
          imageHeader = readImageHeader(buffer, imageOffset);
          imageSize = getImageSize(imageHeader[0]);
          imageOffset += imageHeader[1];
          result.images.push(imageSize);
        }
        return result;
      }
    };
  }
});

// node_modules/image-size/dist/types/j2c.js
var require_j2c = __commonJS({
  "node_modules/image-size/dist/types/j2c.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.J2C = void 0;
    exports.J2C = {
      validate(buffer) {
        return buffer.toString("hex", 0, 4) === "ff4fff51";
      },
      calculate(buffer) {
        return {
          height: buffer.readUInt32BE(12),
          width: buffer.readUInt32BE(8)
        };
      }
    };
  }
});

// node_modules/image-size/dist/types/jp2.js
var require_jp2 = __commonJS({
  "node_modules/image-size/dist/types/jp2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JP2 = void 0;
    var BoxTypes = {
      ftyp: "66747970",
      ihdr: "69686472",
      jp2h: "6a703268",
      jp__: "6a502020",
      rreq: "72726571",
      xml_: "786d6c20"
    };
    var calculateRREQLength = (box) => {
      const unit = box.readUInt8(0);
      let offset = 1 + 2 * unit;
      const numStdFlags = box.readUInt16BE(offset);
      const flagsLength = numStdFlags * (2 + unit);
      offset = offset + 2 + flagsLength;
      const numVendorFeatures = box.readUInt16BE(offset);
      const featuresLength = numVendorFeatures * (16 + unit);
      return offset + 2 + featuresLength;
    };
    var parseIHDR = (box) => {
      return {
        height: box.readUInt32BE(4),
        width: box.readUInt32BE(8)
      };
    };
    exports.JP2 = {
      validate(buffer) {
        const signature = buffer.toString("hex", 4, 8);
        const signatureLength = buffer.readUInt32BE(0);
        if (signature !== BoxTypes.jp__ || signatureLength < 1) {
          return false;
        }
        const ftypeBoxStart = signatureLength + 4;
        const ftypBoxLength = buffer.readUInt32BE(signatureLength);
        const ftypBox = buffer.slice(ftypeBoxStart, ftypeBoxStart + ftypBoxLength);
        return ftypBox.toString("hex", 0, 4) === BoxTypes.ftyp;
      },
      calculate(buffer) {
        const signatureLength = buffer.readUInt32BE(0);
        const ftypBoxLength = buffer.readUInt16BE(signatureLength + 2);
        let offset = signatureLength + 4 + ftypBoxLength;
        const nextBoxType = buffer.toString("hex", offset, offset + 4);
        switch (nextBoxType) {
          case BoxTypes.rreq:
            const MAGIC = 4;
            offset = offset + 4 + MAGIC + calculateRREQLength(buffer.slice(offset + 4));
            return parseIHDR(buffer.slice(offset + 8, offset + 24));
          case BoxTypes.jp2h:
            return parseIHDR(buffer.slice(offset + 8, offset + 24));
          default:
            throw new TypeError("Unsupported header found: " + buffer.toString("ascii", offset, offset + 4));
        }
      }
    };
  }
});

// node_modules/image-size/dist/readUInt.js
var require_readUInt = __commonJS({
  "node_modules/image-size/dist/readUInt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readUInt = void 0;
    function readUInt(buffer, bits, offset, isBigEndian) {
      offset = offset || 0;
      const endian = isBigEndian ? "BE" : "LE";
      const methodName = "readUInt" + bits + endian;
      return buffer[methodName].call(buffer, offset);
    }
    exports.readUInt = readUInt;
  }
});

// node_modules/image-size/dist/types/jpg.js
var require_jpg = __commonJS({
  "node_modules/image-size/dist/types/jpg.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JPG = void 0;
    var readUInt_1 = require_readUInt();
    var EXIF_MARKER = "45786966";
    var APP1_DATA_SIZE_BYTES = 2;
    var EXIF_HEADER_BYTES = 6;
    var TIFF_BYTE_ALIGN_BYTES = 2;
    var BIG_ENDIAN_BYTE_ALIGN = "4d4d";
    var LITTLE_ENDIAN_BYTE_ALIGN = "4949";
    var IDF_ENTRY_BYTES = 12;
    var NUM_DIRECTORY_ENTRIES_BYTES = 2;
    function isEXIF(buffer) {
      return buffer.toString("hex", 2, 6) === EXIF_MARKER;
    }
    function extractSize(buffer, index) {
      return {
        height: buffer.readUInt16BE(index),
        width: buffer.readUInt16BE(index + 2)
      };
    }
    function extractOrientation(exifBlock, isBigEndian) {
      const idfOffset = 8;
      const offset = EXIF_HEADER_BYTES + idfOffset;
      const idfDirectoryEntries = (0, readUInt_1.readUInt)(exifBlock, 16, offset, isBigEndian);
      for (let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {
        const start = offset + NUM_DIRECTORY_ENTRIES_BYTES + directoryEntryNumber * IDF_ENTRY_BYTES;
        const end = start + IDF_ENTRY_BYTES;
        if (start > exifBlock.length) {
          return;
        }
        const block = exifBlock.slice(start, end);
        const tagNumber = (0, readUInt_1.readUInt)(block, 16, 0, isBigEndian);
        if (tagNumber === 274) {
          const dataFormat = (0, readUInt_1.readUInt)(block, 16, 2, isBigEndian);
          if (dataFormat !== 3) {
            return;
          }
          const numberOfComponents = (0, readUInt_1.readUInt)(block, 32, 4, isBigEndian);
          if (numberOfComponents !== 1) {
            return;
          }
          return (0, readUInt_1.readUInt)(block, 16, 8, isBigEndian);
        }
      }
    }
    function validateExifBlock(buffer, index) {
      const exifBlock = buffer.slice(APP1_DATA_SIZE_BYTES, index);
      const byteAlign = exifBlock.toString("hex", EXIF_HEADER_BYTES, EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES);
      const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;
      const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;
      if (isBigEndian || isLittleEndian) {
        return extractOrientation(exifBlock, isBigEndian);
      }
    }
    function validateBuffer(buffer, index) {
      if (index > buffer.length) {
        throw new TypeError("Corrupt JPG, exceeded buffer limits");
      }
      if (buffer[index] !== 255) {
        throw new TypeError("Invalid JPG, marker table corrupted");
      }
    }
    exports.JPG = {
      validate(buffer) {
        const SOIMarker = buffer.toString("hex", 0, 2);
        return "ffd8" === SOIMarker;
      },
      calculate(buffer) {
        buffer = buffer.slice(4);
        let orientation;
        let next;
        while (buffer.length) {
          const i = buffer.readUInt16BE(0);
          if (isEXIF(buffer)) {
            orientation = validateExifBlock(buffer, i);
          }
          validateBuffer(buffer, i);
          next = buffer[i + 1];
          if (next === 192 || next === 193 || next === 194) {
            const size = extractSize(buffer, i + 5);
            if (!orientation) {
              return size;
            }
            return {
              height: size.height,
              orientation,
              width: size.width
            };
          }
          buffer = buffer.slice(i + 2);
        }
        throw new TypeError("Invalid JPG, no size found");
      }
    };
  }
});

// node_modules/image-size/dist/types/ktx.js
var require_ktx = __commonJS({
  "node_modules/image-size/dist/types/ktx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KTX = void 0;
    var SIGNATURE = "KTX 11";
    exports.KTX = {
      validate(buffer) {
        return SIGNATURE === buffer.toString("ascii", 1, 7);
      },
      calculate(buffer) {
        return {
          height: buffer.readUInt32LE(40),
          width: buffer.readUInt32LE(36)
        };
      }
    };
  }
});

// node_modules/image-size/dist/types/png.js
var require_png = __commonJS({
  "node_modules/image-size/dist/types/png.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PNG = void 0;
    var pngSignature = "PNG\r\n\n";
    var pngImageHeaderChunkName = "IHDR";
    var pngFriedChunkName = "CgBI";
    exports.PNG = {
      validate(buffer) {
        if (pngSignature === buffer.toString("ascii", 1, 8)) {
          let chunkName = buffer.toString("ascii", 12, 16);
          if (chunkName === pngFriedChunkName) {
            chunkName = buffer.toString("ascii", 28, 32);
          }
          if (chunkName !== pngImageHeaderChunkName) {
            throw new TypeError("Invalid PNG");
          }
          return true;
        }
        return false;
      },
      calculate(buffer) {
        if (buffer.toString("ascii", 12, 16) === pngFriedChunkName) {
          return {
            height: buffer.readUInt32BE(36),
            width: buffer.readUInt32BE(32)
          };
        }
        return {
          height: buffer.readUInt32BE(20),
          width: buffer.readUInt32BE(16)
        };
      }
    };
  }
});

// node_modules/image-size/dist/types/pnm.js
var require_pnm = __commonJS({
  "node_modules/image-size/dist/types/pnm.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PNM = void 0;
    var PNMTypes = {
      P1: "pbm/ascii",
      P2: "pgm/ascii",
      P3: "ppm/ascii",
      P4: "pbm",
      P5: "pgm",
      P6: "ppm",
      P7: "pam",
      PF: "pfm"
    };
    var Signatures = Object.keys(PNMTypes);
    var handlers = {
      default: (lines) => {
        let dimensions = [];
        while (lines.length > 0) {
          const line = lines.shift();
          if (line[0] === "#") {
            continue;
          }
          dimensions = line.split(" ");
          break;
        }
        if (dimensions.length === 2) {
          return {
            height: parseInt(dimensions[1], 10),
            width: parseInt(dimensions[0], 10)
          };
        } else {
          throw new TypeError("Invalid PNM");
        }
      },
      pam: (lines) => {
        const size = {};
        while (lines.length > 0) {
          const line = lines.shift();
          if (line.length > 16 || line.charCodeAt(0) > 128) {
            continue;
          }
          const [key, value] = line.split(" ");
          if (key && value) {
            size[key.toLowerCase()] = parseInt(value, 10);
          }
          if (size.height && size.width) {
            break;
          }
        }
        if (size.height && size.width) {
          return {
            height: size.height,
            width: size.width
          };
        } else {
          throw new TypeError("Invalid PAM");
        }
      }
    };
    exports.PNM = {
      validate(buffer) {
        const signature = buffer.toString("ascii", 0, 2);
        return Signatures.includes(signature);
      },
      calculate(buffer) {
        const signature = buffer.toString("ascii", 0, 2);
        const type = PNMTypes[signature];
        const lines = buffer.toString("ascii", 3).split(/[\r\n]+/);
        const handler = handlers[type] || handlers.default;
        return handler(lines);
      }
    };
  }
});

// node_modules/image-size/dist/types/psd.js
var require_psd = __commonJS({
  "node_modules/image-size/dist/types/psd.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PSD = void 0;
    exports.PSD = {
      validate(buffer) {
        return "8BPS" === buffer.toString("ascii", 0, 4);
      },
      calculate(buffer) {
        return {
          height: buffer.readUInt32BE(14),
          width: buffer.readUInt32BE(18)
        };
      }
    };
  }
});

// node_modules/image-size/dist/types/svg.js
var require_svg = __commonJS({
  "node_modules/image-size/dist/types/svg.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SVG = void 0;
    var svgReg = /<svg\s([^>"']|"[^"]*"|'[^']*')*>/;
    var extractorRegExps = {
      height: /\sheight=(['"])([^%]+?)\1/,
      root: svgReg,
      viewbox: /\sviewBox=(['"])(.+?)\1/i,
      width: /\swidth=(['"])([^%]+?)\1/
    };
    var INCH_CM = 2.54;
    var units = {
      in: 96,
      cm: 96 / INCH_CM,
      em: 16,
      ex: 8,
      m: 96 / INCH_CM * 100,
      mm: 96 / INCH_CM / 10,
      pc: 96 / 72 / 12,
      pt: 96 / 72,
      px: 1
    };
    var unitsReg = new RegExp(`^([0-9.]+(?:e\\d+)?)(${Object.keys(units).join("|")})?$`);
    function parseLength(len) {
      const m = unitsReg.exec(len);
      if (!m) {
        return void 0;
      }
      return Math.round(Number(m[1]) * (units[m[2]] || 1));
    }
    function parseViewbox(viewbox) {
      const bounds = viewbox.split(" ");
      return {
        height: parseLength(bounds[3]),
        width: parseLength(bounds[2])
      };
    }
    function parseAttributes(root) {
      const width = root.match(extractorRegExps.width);
      const height = root.match(extractorRegExps.height);
      const viewbox = root.match(extractorRegExps.viewbox);
      return {
        height: height && parseLength(height[2]),
        viewbox: viewbox && parseViewbox(viewbox[2]),
        width: width && parseLength(width[2])
      };
    }
    function calculateByDimensions(attrs) {
      return {
        height: attrs.height,
        width: attrs.width
      };
    }
    function calculateByViewbox(attrs, viewbox) {
      const ratio = viewbox.width / viewbox.height;
      if (attrs.width) {
        return {
          height: Math.floor(attrs.width / ratio),
          width: attrs.width
        };
      }
      if (attrs.height) {
        return {
          height: attrs.height,
          width: Math.floor(attrs.height * ratio)
        };
      }
      return {
        height: viewbox.height,
        width: viewbox.width
      };
    }
    exports.SVG = {
      validate(buffer) {
        const str = String(buffer);
        return svgReg.test(str);
      },
      calculate(buffer) {
        const root = buffer.toString("utf8").match(extractorRegExps.root);
        if (root) {
          const attrs = parseAttributes(root[0]);
          if (attrs.width && attrs.height) {
            return calculateByDimensions(attrs);
          }
          if (attrs.viewbox) {
            return calculateByViewbox(attrs, attrs.viewbox);
          }
        }
        throw new TypeError("Invalid SVG");
      }
    };
  }
});

// node_modules/image-size/dist/types/tga.js
var require_tga = __commonJS({
  "node_modules/image-size/dist/types/tga.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TGA = void 0;
    exports.TGA = {
      validate(buffer) {
        return buffer.readUInt16LE(0) === 0 && buffer.readUInt16LE(4) === 0;
      },
      calculate(buffer) {
        return {
          height: buffer.readUInt16LE(14),
          width: buffer.readUInt16LE(12)
        };
      }
    };
  }
});

// node_modules/image-size/dist/types/tiff.js
var require_tiff = __commonJS({
  "node_modules/image-size/dist/types/tiff.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TIFF = void 0;
    var fs = require_fs();
    var readUInt_1 = require_readUInt();
    function readIFD(buffer, filepath, isBigEndian) {
      const ifdOffset = (0, readUInt_1.readUInt)(buffer, 32, 4, isBigEndian);
      let bufferSize = 1024;
      const fileSize = fs.statSync(filepath).size;
      if (ifdOffset + bufferSize > fileSize) {
        bufferSize = fileSize - ifdOffset - 10;
      }
      const endBuffer = Buffer.alloc(bufferSize);
      const descriptor = fs.openSync(filepath, "r");
      fs.readSync(descriptor, endBuffer, 0, bufferSize, ifdOffset);
      fs.closeSync(descriptor);
      return endBuffer.slice(2);
    }
    function readValue(buffer, isBigEndian) {
      const low = (0, readUInt_1.readUInt)(buffer, 16, 8, isBigEndian);
      const high = (0, readUInt_1.readUInt)(buffer, 16, 10, isBigEndian);
      return (high << 16) + low;
    }
    function nextTag(buffer) {
      if (buffer.length > 24) {
        return buffer.slice(12);
      }
    }
    function extractTags(buffer, isBigEndian) {
      const tags = {};
      let temp = buffer;
      while (temp && temp.length) {
        const code = (0, readUInt_1.readUInt)(temp, 16, 0, isBigEndian);
        const type = (0, readUInt_1.readUInt)(temp, 16, 2, isBigEndian);
        const length = (0, readUInt_1.readUInt)(temp, 32, 4, isBigEndian);
        if (code === 0) {
          break;
        } else {
          if (length === 1 && (type === 3 || type === 4)) {
            tags[code] = readValue(temp, isBigEndian);
          }
          temp = nextTag(temp);
        }
      }
      return tags;
    }
    function determineEndianness(buffer) {
      const signature = buffer.toString("ascii", 0, 2);
      if ("II" === signature) {
        return "LE";
      } else if ("MM" === signature) {
        return "BE";
      }
    }
    var signatures = [
      // '492049', // currently not supported
      "49492a00",
      "4d4d002a"
      // Big Endian
      // '4d4d002a', // BigTIFF > 4GB. currently not supported
    ];
    exports.TIFF = {
      validate(buffer) {
        return signatures.includes(buffer.toString("hex", 0, 4));
      },
      calculate(buffer, filepath) {
        if (!filepath) {
          throw new TypeError("Tiff doesn't support buffer");
        }
        const isBigEndian = determineEndianness(buffer) === "BE";
        const ifdBuffer = readIFD(buffer, filepath, isBigEndian);
        const tags = extractTags(ifdBuffer, isBigEndian);
        const width = tags[256];
        const height = tags[257];
        if (!width || !height) {
          throw new TypeError("Invalid Tiff. Missing tags");
        }
        return { height, width };
      }
    };
  }
});

// node_modules/image-size/dist/types/webp.js
var require_webp = __commonJS({
  "node_modules/image-size/dist/types/webp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WEBP = void 0;
    function calculateExtended(buffer) {
      return {
        height: 1 + buffer.readUIntLE(7, 3),
        width: 1 + buffer.readUIntLE(4, 3)
      };
    }
    function calculateLossless(buffer) {
      return {
        height: 1 + ((buffer[4] & 15) << 10 | buffer[3] << 2 | (buffer[2] & 192) >> 6),
        width: 1 + ((buffer[2] & 63) << 8 | buffer[1])
      };
    }
    function calculateLossy(buffer) {
      return {
        height: buffer.readInt16LE(8) & 16383,
        width: buffer.readInt16LE(6) & 16383
      };
    }
    exports.WEBP = {
      validate(buffer) {
        const riffHeader = "RIFF" === buffer.toString("ascii", 0, 4);
        const webpHeader = "WEBP" === buffer.toString("ascii", 8, 12);
        const vp8Header = "VP8" === buffer.toString("ascii", 12, 15);
        return riffHeader && webpHeader && vp8Header;
      },
      calculate(buffer) {
        const chunkHeader = buffer.toString("ascii", 12, 16);
        buffer = buffer.slice(20, 30);
        if (chunkHeader === "VP8X") {
          const extendedHeader = buffer[0];
          const validStart = (extendedHeader & 192) === 0;
          const validEnd = (extendedHeader & 1) === 0;
          if (validStart && validEnd) {
            return calculateExtended(buffer);
          } else {
            throw new TypeError("Invalid WebP");
          }
        }
        if (chunkHeader === "VP8 " && buffer[0] !== 47) {
          return calculateLossy(buffer);
        }
        const signature = buffer.toString("hex", 3, 6);
        if (chunkHeader === "VP8L" && signature !== "9d012a") {
          return calculateLossless(buffer);
        }
        throw new TypeError("Invalid WebP");
      }
    };
  }
});

// node_modules/image-size/dist/types.js
var require_types = __commonJS({
  "node_modules/image-size/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.typeHandlers = void 0;
    var bmp_1 = require_bmp();
    var cur_1 = require_cur();
    var dds_1 = require_dds();
    var gif_1 = require_gif();
    var icns_1 = require_icns();
    var ico_1 = require_ico();
    var j2c_1 = require_j2c();
    var jp2_1 = require_jp2();
    var jpg_1 = require_jpg();
    var ktx_1 = require_ktx();
    var png_1 = require_png();
    var pnm_1 = require_pnm();
    var psd_1 = require_psd();
    var svg_1 = require_svg();
    var tga_1 = require_tga();
    var tiff_1 = require_tiff();
    var webp_1 = require_webp();
    exports.typeHandlers = {
      bmp: bmp_1.BMP,
      cur: cur_1.CUR,
      dds: dds_1.DDS,
      gif: gif_1.GIF,
      icns: icns_1.ICNS,
      ico: ico_1.ICO,
      j2c: j2c_1.J2C,
      jp2: jp2_1.JP2,
      jpg: jpg_1.JPG,
      ktx: ktx_1.KTX,
      png: png_1.PNG,
      pnm: pnm_1.PNM,
      psd: psd_1.PSD,
      svg: svg_1.SVG,
      tga: tga_1.TGA,
      tiff: tiff_1.TIFF,
      webp: webp_1.WEBP
    };
  }
});

// node_modules/image-size/dist/detector.js
var require_detector = __commonJS({
  "node_modules/image-size/dist/detector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.detector = void 0;
    var types_1 = require_types();
    var keys = Object.keys(types_1.typeHandlers);
    var firstBytes = {
      56: "psd",
      66: "bmp",
      68: "dds",
      71: "gif",
      73: "tiff",
      77: "tiff",
      82: "webp",
      105: "icns",
      137: "png",
      255: "jpg"
    };
    function detector(buffer) {
      const byte = buffer[0];
      if (byte in firstBytes) {
        const type = firstBytes[byte];
        if (type && types_1.typeHandlers[type].validate(buffer)) {
          return type;
        }
      }
      const finder = (key) => types_1.typeHandlers[key].validate(buffer);
      return keys.find(finder);
    }
    exports.detector = detector;
  }
});

// node_modules/image-size/dist/index.js
var require_dist = __commonJS({
  "node_modules/image-size/dist/index.js"(exports, module) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.types = exports.setConcurrency = exports.disableTypes = exports.disableFS = exports.imageSize = void 0;
    var fs = require_fs();
    var path = require_path();
    var queue_1 = require_queue();
    var types_1 = require_types();
    var detector_1 = require_detector();
    var MaxBufferSize = 512 * 1024;
    var queue = new queue_1.default({ concurrency: 100, autostart: true });
    var globalOptions = {
      disabledFS: false,
      disabledTypes: []
    };
    function lookup(buffer, filepath) {
      const type = (0, detector_1.detector)(buffer);
      if (typeof type !== "undefined") {
        if (globalOptions.disabledTypes.indexOf(type) > -1) {
          throw new TypeError("disabled file type: " + type);
        }
        if (type in types_1.typeHandlers) {
          const size = types_1.typeHandlers[type].calculate(buffer, filepath);
          if (size !== void 0) {
            size.type = type;
            return size;
          }
        }
      }
      throw new TypeError("unsupported file type: " + type + " (file: " + filepath + ")");
    }
    async function asyncFileToBuffer(filepath) {
      const handle = await fs.promises.open(filepath, "r");
      try {
        const { size } = await handle.stat();
        if (size <= 0) {
          throw new Error("Empty file");
        }
        const bufferSize = Math.min(size, MaxBufferSize);
        const buffer = Buffer.alloc(bufferSize);
        await handle.read(buffer, 0, bufferSize, 0);
        return buffer;
      } finally {
        await handle.close();
      }
    }
    function syncFileToBuffer(filepath) {
      const descriptor = fs.openSync(filepath, "r");
      try {
        const { size } = fs.fstatSync(descriptor);
        if (size <= 0) {
          throw new Error("Empty file");
        }
        const bufferSize = Math.min(size, MaxBufferSize);
        const buffer = Buffer.alloc(bufferSize);
        fs.readSync(descriptor, buffer, 0, bufferSize, 0);
        return buffer;
      } finally {
        fs.closeSync(descriptor);
      }
    }
    module.exports = exports = imageSize;
    exports.default = imageSize;
    function imageSize(input, callback) {
      if (Buffer.isBuffer(input)) {
        return lookup(input);
      }
      if (typeof input !== "string" || globalOptions.disabledFS) {
        throw new TypeError("invalid invocation. input should be a Buffer");
      }
      const filepath = path.resolve(input);
      if (typeof callback === "function") {
        queue.push(() => asyncFileToBuffer(filepath).then((buffer) => process.nextTick(callback, null, lookup(buffer, filepath))).catch(callback));
      } else {
        const buffer = syncFileToBuffer(filepath);
        return lookup(buffer, filepath);
      }
    }
    exports.imageSize = imageSize;
    var disableFS = (v) => {
      globalOptions.disabledFS = v;
    };
    exports.disableFS = disableFS;
    var disableTypes = (types) => {
      globalOptions.disabledTypes = types;
    };
    exports.disableTypes = disableTypes;
    var setConcurrency = (c) => {
      queue.concurrency = c;
    };
    exports.setConcurrency = setConcurrency;
    exports.types = Object.keys(types_1.typeHandlers);
  }
});
export default require_dist();
//# sourceMappingURL=image-size.js.map
